<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Tableaux, exceptions | NFP121 Millau</title>
    <meta name="description" content="Suite de la syntaxe java non-objet : tableaux, exceptions.">
    <meta name="robots" content="index,follow">
    <link href="../../static/style.css" rel="stylesheet" type="text/css">
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.rights" content="Creative commons by-sa 4.0">
    <meta name="dcterms.rightsHolder" content="Thierry Graff">
    <meta name="dcterms.dateCopyrighted" content="2017">
</head>
<body>

<nav class="prevnext">
    <a class="top" title="Cours CNAM" href="../../index.html">&uarr;</a>
    <a class="prev" title="Previous" href="syntaxe-java1.html">&larr;</a>
    <a class="next" title="Next" href="syntaxe-java3.html">&rarr;</a>
</nav>

<header>
<h1>Tableaux, exceptions</h1>
<nav class="toc">
    <ul>
        <li>
            <a href="#1-les-tableaux">Les tableaux</a>
            <ul>
                <li><a href="#1-1-array-initializers">Array initializers</a></li>
                <li><a href="#1-2-utilisation-des-tableaux">Utilisation des tableaux</a></li>
            </ul>
        </li>
        <li>
            <a href="#2-les-exceptions">Les exceptions</a>
            <ul>
                <li><a href="#2-1-les-classes-d-exception">Les classes d'exception</a></li>
                <li><a href="#2-2-creer-ses-propres-exceptions">Créer ses propres exceptions</a></li>
                <li><a href="#2-3-lancer-des-exceptions">Lancer des exceptions</a></li>
                <li><a href="#2-4-propagation-des-exceptions">Propagation des exceptions</a></li>
                <li><a href="#2-5-try-with-resources-twr">try with resources (TWR)</a></li>
            </ul>
        </li>
    </ul>
</nav>

</header>

<article>

<!-- ********************************************************************************* -->
<h2><a name="1-les-tableaux">Les tableaux</a></h2>
Un tableau (array) est un type particulier d'objet, qui contient 0 ou plusieurs instances de type référence ou primitif, que l'on appelle <b>éléments</b> du tableau.
<br>Le type d'un tableau est caractérisé par le type de ses éléments (tous les éléments d'un tableau doivent être du même type).
<br>Les éléments d'un tableau n'ont pas de nom, ils sont repérés par leur <b>index</b>, qui commence à 0.
<br>Le nombre d'élément d'un tableau est stocké dans une propriété <code>length</code> ; la taille du tableau doit être spécifiée à la création et ne peut pas changer.
<br>Un tableau peut contenir tout type d'objet, notamment des tableaux, ce qui permet de gérer des tableaux à plusieurs dimensions.
<br>
<br>Comme les classes, les tableaux sont un type référence. Les instances d'un tableau sont donc des objets, qui héritent des méthodes de <code>java.lang.Object</code>.
<br>
<br>Pour définir un tableau on utilise les crochets (brackets) <code>[ ]</code> :
<pre>
byte b;                         // declaration of a variable
byte[] arrayOfBytes;            // byte[] is an array of byte values
byte[][] arrayOfArrayOfBytes;   // byte[][] is an array of byte[]
String[] points;                // String[] is an array of strings
</pre>
Ici, la variable <code>points</code> est de type <code>String[]</code>. Mais la longueur du tableau ne fait pas partie de son type, on ne peut pas créer de type "un tableau contenant 4 strings".
<br>
<br>Lorsqu'on passe en paramètre un tableau, le type de tableau fait donc partie de la signature de la méthode.
<br>Par exemple <code>public static int max(int[] x)</code> n'acceptera pas un tableau de <code>float</code>.
<br>
<br>Pour créer un tableau, on utilise le mot-clé <code>new</code>, comme pour un objet :
<pre>String[] lines = new String[50];</pre>
Lorsqu'on crée un tableau, chaque élément est automatiquement initialisé avec les mêmes valeurs utilisées pour les variables d'une classe (<code>false</code> pour un booléen, <code>\u0000</code> pour un char, <code>0</code> un entier, <code>0.0</code> pour un nombre réel, et <code>null</code> pour un type référence).

<!-- ************************************* -->
<h3><a name="1-1-array-initializers">Array initializers</a></h3>

De la même manière qu'on peut initialiser une chaîne avec une syntaxe spéciale sans utiliser <code>new</code>, on peut initialiser un tableau :
<pre>
String[] greetings = new String[] { "Hello", "Hi", "Howdy" };
int[] smallPrimes = new int[] { 2, 3, 5, 7, 11, 13, 17, 19, };
</pre>

On parle d'<b>array litterals</b>
<br>Cette syntaxe permet de créer un tableau sans utiliser <code>new</code>
<br>
<br>Elle permet aussi d'utiliser des tableaux sans les assigner à des variables (en quelque sorte des "tableaux anonymes") :
<pre>
double d = computeAreaOfTriangle(new Point[] { new Point(1,2), new Point(3,4), new Point(3,2) });
</pre>

Les array litterals sont créés et initialisés à l'exécution, et pas à la compilation.
<pre>
int[] perfectNumbers = {6, 28};
</pre>
A la compilation, cela est traduit en :
<pre>
int[] perfectNumbers = new int[2];
perfectNumbers[0] = 6;
perfectNumbers[1] = 28;
</pre>
Une conséquence importante est qu'on peut mettre dans un array litterals des choses qui ne sont pas fixes, par exemple
<pre>Point[] points = { circle1.getCenterPoint(), circle2.getCenterPoint() };</pre>

<!-- ************************************* -->
<h3><a name="1-2-utilisation-des-tableaux">Utilisation des tableaux</a></h3>

On utilise les brackets <code>[ ]</code> pour accéder aux éléments d'un tableau :
<pre>
String[] responses = new String[2];
responses[0] = "Yes";
responses[1] = "No";
System.out.println(question + " (" + responses[0] + " / " + responses[1] + " ) : ");
</pre>

Si <code>t</code> est un tableau, <code>t[0]</code> est son premier élément, <code>t[1]</code> le second ... et <code>t[t.length-1]</code> est le dernier.
<br>
<br>Pour parcourir un tableau, on peut utilise typiquement une boucle for ou foreach:
<pre>
int[] primes = { 2, 3, 5, 7, 11, 13, 17, 19, 23 };
int sumOfPrimes = 0;

for(int i = 0; i < primes.length; i++){
    sumOfPrimes += primes[i];
}
// ou bien
for(int p : primes){
    sumOfPrimes += p;
}
</pre>

La classe <code>java.util.Arrays</code> contient de nombreuses méthodes pour manipuler les tableaux.

<h4>Tableau à plusieurs dimensions</h4>
S'utilisent comme les tableaux à une dimension.
<br>Il n'est pas nécessaire de spécifier toutes les length à la création, seule la première est nécessaire, et il faut les spécifier par la gauche :
<pre>
float[][][] tableau3D = new float[360][180][100];
float[][][] tableau3D = new float[360][180][];
float[][][] tableau3D = new float[360][][];
</pre>
Mais à l'utilisation, il faudra spécifier les tailles avant de les utiliser :
<pre>
int[][] t = new int[10][];
for(int i = 0; i < t.length; i++){
    t[i] = new int[i];      // ici, on a pu déclarer un tableau qui n'est pas "carré"
    for(int j = 0; j < t[i].length; j++){
        System.out.println("i = " + i + " - j = " + j);
    }
    System.out.println();
}
</pre>
Les array initializers peuvent être aussi utilisés pour des tableaux à plusieurs dimensions :
<pre>
int[][] products = {
    {0, 0, 0, 0, 0},
    {0, 1, 2, 3, 4},
    {0, 4, 8, 12, 16}, // remarquer la dernière virgule (facultative)
};
</pre>
De la même manière, on peut avoir des "tableaux anonymes".

<div class="exo">
    <b>Exercice</b> <a href="../../exos/java/max/Max.html">Max et moyenne</a>
</div>
<div class="exo">
    <b>Exercice</b> <a href="../../exos/java/voitures/Voitures.html">Voitures</a>
</div>
<div class="exo">
    <b>Exercice</b> <a href="../../exos/java/premiers/Premiers.html">Nombres premiers</a>
</div>

<!-- ********************************************************************************* -->
<h2><a name="2-les-exceptions">Les exceptions</a></h2>
Les exceptions sont un mécanisme de propagation des erreurs.
<br>Très pratique car permet d'écrire du code plus lisible, non pollué par la gestion des cas d'erreur.
<br>
<br>Le mécanisme des exceptions utilise 5 mots-clés du langage : <code><b>try</b></code>, <code><b>catch</b></code>, <code><b>finally</b></code>, <code><b>throw</b></code> et <code><b>throws</b></code>.
<br>
<br>Sans les exceptions :
<pre>
fonction ContenuDuFichier(String filename){

    ouvrirFichier(filename)
    
    si erreur d'ouverture
        return null
    
    String contentu = lireFichier
    
    Si erreur de lecture
        return null
    
    return contenu
}
</pre>
Avec les exceptions :
<pre>
fonction ContenuDuFichier(String filename){
    <b>try</b>{
        ouvrirFichier(filename)
        String contentu = lireFichier
        return contenu
    }
    <b>catch</b>(ErreurOuverture e){
        return null
    }
    <b>catch</b>(ErreurLecture e){
        return null
    }
}
</pre>

En plus de <code>try</code> et <code>catch</code>, on peut définir un bloc <code>finally</code>, qui va s'exécuter dans tous les cas, qu'une exception ait été lancée ou pas.
<br>Le bloc <code>finally</code> est exécuté même si une exception est propagée ; utile par exemple pour fermer une connexion réseau ou à une base de données.
<br><code>catch</code> et <code>finally</code> sont optionnels, mais au moins un des deux est nécessaire.
<br>Les accolades sont obligatoires dans ces blocs, même s'ils ne contiennent qu'une ligne.
<br>

<pre>
try {

    // instructions
    
} catch(ExceptionType1 e){
    // traitement de ce cas anormal de type ExceptionType1
    // e est de type ExceptionType1
}

catch(ExceptionType2){
    // traitement de ce cas anormal de type ExceptionType2
    // e est de type ExceptionType2
}

<b>finally</b> {
    traitement de fin de bloc try
}
</pre>

Une même clause <code>catch</code> peut gérer plusieurs types d'exception, en les séparant par <code>|</code>.
<pre>
try{
    ...
}
catch(<b>ExceptionType1 | ExceptionType2 e</b>){
    // la variable e est un objet de type ExceptionType1 ou ExceptionType2
}
</pre>


<!-- ************************************* -->
<h3><a name="2-1-les-classes-d-exception">Les classes d'exception</a></h3>

Les exceptions que l'on peut lancer ou attrapper sont des objets de type <code>java.lang.Exception</code> ou de ses sous-classes.
<br>L'API java fournit un grand nombre de classes :

<img class="margin padding05 border" src="img/throwable.jpg" alt="Hiérarchie Throwable" />


<br>On distingue 2 types principaux d'exceptions : 
<br>- les exceptions vérifiées (<b>checked exceptions</b>), qui peuvent être anticipées et doivent être gérées par l'application.
<br>- les exceptions non vérifiées (<b>unchecked exceptions</b>), qui ne peuvent pas être anticipées (par ex <code>OutOfMemoryError</code>).
<br>Les unchecked exceptions descendent de <code>Error</code> ou de <code>RuntimeException</code> .
<br>
<br>Une exception contient un message, accessible via <code>getMessage()</code>.
<br><code>printStackTrace()</code> est aussi courrament utilisée.


<!-- ************************************* -->
<h3><a name="2-2-creer-ses-propres-exceptions">Créer ses propres exceptions</a></h3>
On peut créer des exceptions personnalisées en sous-classant <code>Exception</code> :

<pre>public MyException extends Exception {}</pre>

Dans le code qu'on écrit on a le choix entre utiliser <code>Exception</code> et ses sous-classes lorsque c'est pertinent, ou les classes d'exceptions spécifiques à l'application.

<!-- ************************************* -->
<h3><a name="2-3-lancer-des-exceptions">Lancer des exceptions</a></h3>
Une exception est "lancée" avec l'instruction <code>throw</code> lorsqu'une condition anormale d'exécution est rencontrée :
<pre>
public static double factorial(int x) throws IllegalArgumentException{
    if (x < 0)
        <b>throw new IllegalArgumentException("x must be >= 0")</b>;
    double fact;
    for(fact=1.0; x > 1; fact *= x, x--)
        ; // instruction vide
    return fact;
}
</pre>

(code dans <a href="../../exemples/java/factorial/Factorial.java">Factorial.java</a>)

<!-- ************************************* -->
<h3><a name="2-4-propagation-des-exceptions">Propagation des exceptions</a></h3>

Si l'interpréteur java rencontre une exception, il arrête l'exécution du code et cherche un gestionnaire d'exception (un bloc <code>catch</code>).
<br>
L'interpréteur java va remonter la pile d'appel des méthodes jusqu'à ce qu'il trouve un bloc <code>catch</code> correspondant au type de l'exception en cours ou à une superclasse.
<br>Par exemple, si on se place dans une méthode qui utilise <code>factorial()</code> :
<pre>
void maMéthode(){
    ...
    double f = factorial(-5);
    ...
}
</pre>

- Soit <code>maMéthode()</code> contient un bloc try catch gérant <code>IllegalArgumentException</code>
<pre>
void maMéthode(){
    try{
        ...
        double f = factorial(-5);
        ...
    }
    catch(IllegalArgumentException e){
        // gestion de e
    }
}
</pre>
Dans ce cas le code présent dans ce bloc catch sera exécuté.
<br>
<br>- Soit <code>maMéthode()</code> ne gère pas <code>IllegalArgumentException</code> et doit alors obligatoirement déclarer qu'elle est susceptible de lancer une exception avec le mot-clé <code>throws</code> :

<pre>
void maMéthode <b>throws IllegalArgumentException</b>(){
    ...
    double f = factorial(-5);
    ...
}
</pre>

Dans ce cas, l'exception sera propagée à la méthode qui a appelé <code>maMéthode()</code>, ainsi de suite jusqu'à la fonction <code>main()</code>.
<br>Donc en général, le code d'une fonction <code>main()</code> contient un try catch :
<pre>
public static void main(String[] args) {
    try{
    }
    catch(Exception e){
    }
</pre>
Dans ce cas, on a intérêt à utiliser la classe <code>Exception</code>, qui est la superclasse de toutes les autres exceptions, çe qui permet de rattrapper toute erreur imprévue dans le programme, quelque soit son type.
<br>
<br>A noter : les blocs <code>catch</code> sont évalués les uns après les autres. Le compilateur impose donc que les cas particuliers soient traités d'abord.

<pre>
void maMéthodeQuiNePassePasALaCompil(){
    try{
        ...
        double f = factorial(-5);
        ...
    }
    catch(Exception e){
    }
    catch(IllegalArgumentException e){
    }
}
</pre>
Si ce code passait à la compilation, le <code>catch</code> de <code>IllegalArgumentException</code> ne serait jamais appelé puisque c'est une sous-classe de <code>Exception</code>.

<!-- ************************************* -->
<h3><a name="2-5-try-with-resources-twr">try with resources (TWR)</a></h3>
Voir <a href="io.html#1-3-try-with-resources-twr">le cours sur java.io</a>

<div class="exo">
    <b>Exercice</b> <a href="../../exos/java/multiples/Multiples2.html">Multiples2</a>
</div>


<!-- ************************************* -->
<!-- ********************************************************************************* -->

</article>

</body>
</html>
