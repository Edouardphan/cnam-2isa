<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <title>Syntaxe java, suite | NFP121 Millau</title>
    <meta name="description" content="Suite de la syntaxe java : les types référence, les méthodes et les packages.">
    <meta name="robots" content="index,follow">
    <link href="../../static/style.css" rel="stylesheet" type="text/css">
    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.rights" content="Creative commons by-sa 4.0">
    <meta name="dcterms.rightsHolder" content="Thierry Graff">
    <meta name="dcterms.dateCopyrighted" content="2017">
</head>
<body>

<nav class="prevnext">
    <a class="top" title="Cours CNAM" href="../../index.html">&uarr;</a>
    <a class="prev" title="Previous" href="syntaxe-java1.html">&larr;</a>
    <a class="next" title="Next" href="classes-interfaces.html">&rarr;</a>
</nav>

<header>
<h1>Syntaxe java, suite</h1>
<nav class="toc">
    <ul>
        <li>
            <a href="#1-les-types-reference">Les types référence</a>
            <ul>
                <li><a href="#1-1-copie">Copie</a></li>
                <li><a href="#1-2-comparaison">Comparaison</a></li>
                <li><a href="#1-3-passage-en-parametre">Passage en paramètre</a></li>
                <li><a href="#1-4-autoboxing">Autoboxing</a></li>
            </ul>
        </li>
        <li>
            <a href="#2-les-methodes">Les méthodes</a>
            <ul>
                <li><a href="#2-1-definir-une-methode">Définir une méthode</a></li>
                <li><a href="#2-2-polymorphisme-ad-hoc">Polymorphisme ad'hoc</a></li>
                <li><a href="#2-3-les-modifiers">Les modifiers</a></li>
                <li><a href="#2-4-les-arguments">Les arguments</a></li>
                <li><a href="#2-5-retour-d-une-methode">Retour d'une méthode</a></li>
            </ul>
        </li>
    </ul>
</nav>

</header>

<article>



















<!-- ********************************************************************************* -->
<h2><a name="1-les-types-reference">Les types référence</a></h2>

<!-- ************************************* -->
<h3><a name="1-1-copie">Copie</a></h3>
<!-- todo : rajouter schéma -->
En java, les références sont complètement opaques, on ne peut pas comme en C les manipuler (en C, opérateurs <code>&</code>, <code>*</code> et <code>-></code>)
<br>Cela a une importance lorsqu'on duplique des variables :
<pre>
int a = 42;
int b = a;
</pre>
Pour les types primitifs, la JVM stocke 2 fois la valeur 42 dans 2 endroits différents de sa mémoire.
<pre>
int a = 42;
int b = a;
a = 43;
System.out.println(a);      // affiche 43
System.out.println(b);      // affiche 42
</pre>

Mais si on fait la même chose avec une classe :
<pre>
class Point {
    public int x, y;
    public Point(int x, int y) { this.x = x; this.y = y; }
    public String toString(){ return "(" + this.x + "," + this.y + ")"; } // noter au passage la redéfinition d'une méthode de Object
}
Point a = new Point(1, 1);
Point b = a;
a.x = 2;
System.out.println(a); // affiche (2,1)
System.out.println(b); // affiche (2,1)
</pre>
<br>Comme <code>a</code> et <code>b</code> pointent vers la même chose, toute modification de l'un sera répercutée sur l'autre.


<h4>Clone</h4>

La classe <code>Object</code> fournit une méthode <code>clone()</code> dont toutes les classes héritent, mais elle ne fait que copier les références (shallow copy).
<br>L'API java fournit des méthodes de recopie pour certaines classes.
<br>Par exemple, pour dupliquer 2 tableaux, on dispose de <code>System.arraycopy()</code>.
<br>Mais si on a besoin de recopier des objets de nos propres classes, on doit l'implémenter.


<!-- ************************************* -->
<h3><a name="1-2-comparaison">Comparaison</a></h3>
Lorsqu'on utilise l'opérateur de comparaison <code>==</code> pour les types primitifs, java compare leurs valeurs (est évalué à <code>true</code> s'ils ont exactement les mêmes bits), donc on a le résultat attendu.
<br>Mais si on compare 2 types référence, java compare leurs références, pas leurs valeurs.
<pre>
String s = "hello";
String letter = "o";

String t = "hell" + letter;

System.out.println("avec == \t" + (s == t ? "equal" : "not equal"));

System.out.println("avec equals \t" + (s.equals(t) ? "equal" : "not equal"));
</pre>
à l'exécution :
<pre>
avec ==         not equal
avec equals     equal
</pre>
Comme on pouvait s'y attendre, le test avec <code>==</code> indique que <code>s</code> et <code>t</code> ne sont pas égales.
<br>Pour faire le test correctement, on a utilisé la méthode <code>equals()</code>.
Cette méthode fait partie de la classe <code>java.lang.Object</code>, donc toutes les classes en héritent, mais dans le cas général, elle n'est pas plus utile, car l'implémentation par défaut utilise simplement <code>==</code> pour faire la comparaison.
<br>Le test a marché uniquement parceque la classe <code>String</code> réimplémente <b>equals()</b>.
<br>
<br>Pour comparer les valeurs des tableaux, il faut par exemple utiliser <code>java.util.Arrays.equals()</code> ou <code>java.util.Arrays.deepEquals()</code> pour les tableaux à plusieurs dimensions.
<!-- 
<br>
<br>On pourrait être tenté d'utiliser <code>java.lang.Object.hashCode()</code> pour tester l'égalité, mais ce n'est pas possible sans redéfinir <code>hashCode()</code>, car la règle est :
<br>- Si 2 objets sont égaux, ils doivent avoir le même hash code.
<br>- Si 2 objets sont différents, il <i>peuvent</i> avoir le même hash code.
-->


<!-- ************************************* -->
<h3><a name="1-3-passage-en-parametre">Passage en paramètre</a></h3>
<!-- important -->
Le même phénomène se produit lorsqu'on passe une variable en paramètre : 
<pre>
void changePrimitive(int x){
    x--;
}
int a = 42;
System.out.println(a);      // affiche 42
changePrimitive(a);
System.out.println(a);      // affiche 42
</pre>
Mais avec un type référence :
<pre>
void changeReference(Point p) {
    p.x--;
}
Point a = new Point(1, 1);
System.out.println(a); // affiche (1,1)
changeReference(a);
System.out.println(a); // affiche (0,1)
</pre>

<!-- ************************************* -->
<h3><a name="1-4-autoboxing">Autoboxing</a></h3>
Il peut être utile de traduire des types primitifs en objet.
<br>Pour ça, java fournit des <i>wrapper classes</i> pour chaque type primitif : <code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Character</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, et <code>Double</code>.
<br>Passer du type primitif à sa représentation objet s'appelle le <b>boxing</b>, l'inverse <b>unboxing</b>.
<br>On peut le faire "à la main" :
<pre>
myInt = new Integer(-1);            // deprecated, faire à la place : Integer.valueOf(-1)
int i = myInt.intValue();
</pre>
Mais pas très pratique, java le fait automatiquement (<b>autoboxing</b>) :
<pre>
Integer i = 0;      // int literal 0 boxed to an Integer object
Number n = 0.0f;    // float literal boxed to Float and widened to Number
Integer i = 1;      // this is a boxing conversion
int j = i;          // i is unboxed here
i++;                // i is unboxed, incremented, and then boxed up again
Integer k = i+2;    // i is unboxed and the sum is boxed up again
i = null;
j = i; 
</pre>

<!-- ********************************************************************************* -->
<h2><a name="2-les-methodes">Les méthodes</a></h2>

<!-- ************************************* -->
<h3><a name="2-1-definir-une-methode">Définir une méthode</a></h3>
Une méthode est définie par sa <b>signature</b>, qui doit être unique au sein d'une classe.
<br>La signature d'une méthode est composée de :
<ul>
    <li>ses <i>modifiers</i></li>
    <li>son nom</li>
    <li>le nombre, l'ordre, les types et les noms de ses paramètres</li>
    <li>le type de la valeur qu'elle renvoie</li>
    <li>les checked exceptions qu'elle est susceptible de lancer</li>
</ul>
<code>modifiers type name ( paramlist ) [ throws exceptions ]</code>

<pre>
public static void myMethod(int param1, float param2) throws FileNotFoundException, FileSystemException{ ... }
<span class="red">modifiers     type name    ( paramlist )            [ throws exceptions ]</span>
</pre>
La signature est suivie par le corps de la méthode (une suite d'instructions entourée par des accolades).
<br>Si la méthode est abstraite (si le mot-clé <code>abstract</code> fait partie de sa signature), le corps est remplacé par un point-virgule.

<!-- ************************************* -->
<h3><a name="2-2-polymorphisme-ad-hoc">Polymorphisme ad'hoc</a></h3>
Une méthode doit avoir une signature unique au sein d'une classe, mais il peut exister plusieurs méthodes du même nom, ce qu'on appelle le <b>polymorphisme ad'hoc</b> ou <b>overloading</b>.
<br>C'est très fréquemment utilisé en java, par exemple la classe <code>java.lang.System</code> a une variable static nommée <code>out</code>, qui est un objet de la classe <code>java.io.PrintStream</code>. Cette classe possède plusieurs méthodes <code>println()</code>, dont les signatures diffèrent par le type de l'argument à afficher.
<br>Cela permet d'utiliser <code>System.out.println(maVariable)</code> sans se soucier du type de <code>maVariable</code>.

<!-- ************************************* -->
<h3><a name="2-3-les-modifiers">Les modifiers</a></h3>
Liste de zéro ou plusieurs mots-clés.
<br>
<br>Modifiers traités dans ce cours :
<ul>
    <li>
        <code>abstract</code> : méthode abstraite, sans implémentation.
    </li>
    <li>
        <code>final</code> : Ne peut pas être overridé dans les sous classes ; permet au compilateur de faire des optimisations ; les méthodes privées sont implicitement toutes final.
    </li>
    <li>
        <code>public, protected, private</code> : indiquent la visibilité de la méthode ; l'absence de modifier désignant la visibilité désigne aussi une visibilité (cf plus loin).
    </li>
    <li>
        <code>static</code> : Indique s'il s'agit d'une méthode de classe (static) ou d'instance (pas déclarée static).
    </li>
</ul>
Autres modifiers, non traités :
<ul>
    <li>
        <code>native</code> : indiquent une méthode implémenté dans un autre langage (comme le C). Pas d'implémentation, les accolades sont remplacées par un <code>;</code>
    </li>
    <li>
        <code>strictfp</code> : lié à la manière dont java gère l'armitmétique en floating point.
    </li>
    <li>
        <code>synchronized</code> : lié au multithread.
    </li>
</ul>

<!-- ************************************* -->
<h3><a name="2-4-les-arguments">Les arguments</a></h3>
Comme déjà vu, les arguments sont une liste séparée par des virgules contenant le type et le nom des arguments.
<br>Le type des arguments n'est donc pas limité aux types primitifs, par ex <code>public void myMethod(int arg1, String arg2)</code>

<h4>Liste d'arguments variables</h4>
java permet à une fonction d'avoir un nombre variable d'arguments, <i>qui doivent être tous du même type</i>.
<br>Les arguments variables doivent être placés en dernier ; on utilise <code>...</code> pour les définir.
<br>Cette possibilité s'appelle <b>varargs</b>.
<br>Exemple d'une fonction qui calcule le plus grand entier :
<pre>public static int max(int premier, int... lesAutres) { /* implementation */ }</pre>
Java transforme à la compilation les arguments variables en tableau et voit la méthode comme :
<pre>public static int max(int premier, int[] lesAutres) { /* implementation */ }</pre>
Dans la méthode, on peut donc utiliser l'argument variable comme un tableau :
<pre>
public static int max(int premier, int... lesAutres) {
    int max = premier;
    for(int i : lesAutres) {
        if (i > max) max = i;
    }
    return max;
}
</pre>
On peut utiliser la fonction avec autant d'arguments que l'on veut :
<pre>
max(0)
max(1, 2)
max(16, 8, 4, 2, 1)
</pre>
(code dans <a href="../../exemples/java/varargs/Varargs.java">Varargs.java</a>)
<br>
<br>A noter la fonction <code>public static main(String[] args)</code> peut être écrite <code>public static void main(String... args)</code>
<br>(voir <a href="../../exemples/java/varargs/SignatureVarargs.java">SignatureVarargs.java</a>)


<!-- ************************************* -->
<h3><a name="2-5-retour-d-une-methode">Retour d'une méthode</a></h3>
Si elle n'est pas déclarée <code>void</code>, une méthode peut renvoyer un objet du type spécifié dans sa signature.
<br>L'instruction <code>return</code> peut se trouver à n'importe quel endroit du corps de la méthode.
<br>Si la méthode est déclarée <code>void</code> et qu'elle ne contient aucun return, elle s'exécute jusqu'au bout et retourne après avoir exécuté la dernière instruction.
<br>L'exécution de la fonction peut aussi être interrompue par des instructions <code>throw</code>, ou si une exception survient.


</article>

</body>
</html>

<!-- ************************************* -->
<!-- ********************************************************************************* -->

ode est déclarée <code>void</code> et qu'elle ne contient aucun return, elle s'exécute jusqu'au bout et retourne après avoir exécuté la dernière instruction.
<br>L'exécution de la fonction peut aussi être interrompue par des instructions <code>throw</code>, ou si une exception survient.


</article>

</body>
</html>

<!-- ************************************* -->
<!-- ********************************************************************************* -->

